#include "unity.h"

#include "settings.h"

// Mocks generated by Ceedling/CMock:
#include "mock_w25q128jv.h"
#include "mock_hal_gpio.h"
#include "mock_serial_print.h"

// for GPIOA/GPIO_PIN_4 constants
#include "stm32_hal_stubs.h"

void setUp(void) {
    // reset globals to known values before each test
    memset(&firmSettings, 0, sizeof(firmSettings));
    memset(&calibrationSettings, 0, sizeof(calibrationSettings));
}

void tearDown(void) {}

static void fill_sector(uint8_t* buf, uint8_t val) {
    memset(buf, val, SETTINGS_FLASH_BLOCK_SIZE_BYTES);
}

/**
 * settings_write_firm_settings: NULL guard
 */
void test_settings_write_firm_settings_null_returns_false(void) {
    TEST_ASSERT_FALSE(settings_write_firm_settings(NULL));
}

/**
 * settings_write_calibration_settings: NULL guard
 */
void test_settings_write_calibration_settings_null_returns_false(void) {
    TEST_ASSERT_FALSE(settings_write_calibration_settings(NULL));
}

/**
 * settings_write_firm_settings sanitizes null terminators and writes correct bytes
 */
void test_settings_write_firm_settings_sanitizes_and_updates_global(void) {
    uint8_t sector[SETTINGS_FLASH_BLOCK_SIZE_BYTES];
    fill_sector(sector, 0xAA);

    // Ceedling mock: when settings.c reads flash, copy our buffer out
    w25q128jv_read_sector_ExpectAnyArgs();
    w25q128jv_read_sector_ReturnThruPtr_buf(sector);

    // Expect erase + write for the whole block
    w25q128jv_erase_sector_Expect(0);
    w25q128jv_write_sector_ExpectAnyArgs();

    // Verification readback: settings.c reads back chunks; easiest is just always return what it wrote.
    // We'll cheat by making read_sector always return the same "sector" contents.
    // After write_sector, sector should contain updated firm settings bytes (we’ll check via callback).
    // Use a callback on write_sector to capture the written buffer.
    static uint8_t written_block[SETTINGS_FLASH_BLOCK_SIZE_BYTES];
    void write_cb(const uint8_t* buf, int sector_id, int offset, int len, int cmock_num_calls) {
        (void)sector_id; (void)offset; (void)len; (void)cmock_num_calls;
        memcpy(written_block, buf, SETTINGS_FLASH_BLOCK_SIZE_BYTES);
        // also mirror it into sector so verify passes
        memcpy(sector, buf, SETTINGS_FLASH_BLOCK_SIZE_BYTES);
    }
    w25q128jv_write_sector_AddCallback(write_cb);

    // verify loop reads: just return sector (which we mirror to match writes)
    w25q128jv_read_sector_ExpectAnyArgs();
    w25q128jv_read_sector_ReturnThruPtr_buf(sector);

    FIRMSettings_t in = {0};
    in.frequency_hz = 123;
    // Overlong strings (no terminator) to prove sanitize forces terminator
    memset(in.device_name, 'X', sizeof(in.device_name));
    memset(in.firmware_version, 'Y', sizeof(in.firmware_version));

    bool ok = settings_write_firm_settings(&in);
    TEST_ASSERT_TRUE(ok);

    // Global updated and strings are terminated
    TEST_ASSERT_EQUAL_UINT16(123, firmSettings.frequency_hz);
    TEST_ASSERT_EQUAL_CHAR('\0', firmSettings.device_name[sizeof(firmSettings.device_name) - 1]);
    TEST_ASSERT_EQUAL_CHAR('\0', firmSettings.firmware_version[sizeof(firmSettings.firmware_version) - 1]);

    // Confirm the written block actually contains the sanitized struct in the right location
    FIRMSettings_t out = {0};
    memcpy(&out, written_block + sizeof(CalibrationSettings_t), sizeof(FIRMSettings_t));
    TEST_ASSERT_EQUAL_UINT16(123, out.frequency_hz);
    TEST_ASSERT_EQUAL_CHAR('\0', out.device_name[sizeof(out.device_name) - 1]);
    TEST_ASSERT_EQUAL_CHAR('\0', out.firmware_version[sizeof(out.firmware_version) - 1]);
}

/**
 * settings_init: returns error if flash init fails
 */
void test_settings_init_flash_init_fail_returns_1(void) {
    SPI_HandleTypeDef spi = {0};
    GPIO_TypeDef gpio = {0};

    w25q128jv_set_spi_settings_Expect(&spi, &gpio, 5);
    w25q128jv_init_ExpectAndReturn(0);

    TEST_ASSERT_EQUAL_INT(1, settings_init(&spi, &gpio, 5));
}

/**
 * settings_init: UID mismatch -> prints error and returns 1
 */
void test_settings_init_uid_mismatch_returns_1_and_prints(void) {
    SPI_HandleTypeDef spi = {0};
    GPIO_TypeDef gpio = {0};

    w25q128jv_set_spi_settings_ExpectAnyArgs();
    w25q128jv_init_ExpectAndReturn(1);

    // write check pin high => don't write defaults
    HAL_GPIO_ReadPin_ExpectAndReturn(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

    // sector read gives some settings with a device_uid that won’t match
    uint8_t sector[SETTINGS_FLASH_BLOCK_SIZE_BYTES];
    memset(sector, 0, sizeof(sector));
    FIRMSettings_t fs = {0};
    fs.device_uid = 0x1111111111111111ULL;
    memcpy(sector + sizeof(CalibrationSettings_t), &fs, sizeof(fs));

    w25q128jv_read_sector_ExpectAnyArgs();
    w25q128jv_read_sector_ReturnThruPtr_buf(sector);

    // UID read returns different UID
    uint64_t uid = 0x2222222222222222ULL;
    w25q128jv_read_UID_ExpectAnyArgs();
    w25q128jv_read_UID_ReturnThruPtr_out((uint8_t*)&uid);

    serialPrintStr_ExpectAnyArgs();

    TEST_ASSERT_EQUAL_INT(1, settings_init(&spi, &gpio, 5));
}

/**
 * settings_init: if pin pulled low, writes defaults (we just assert it attempts writes)
 */
void test_settings_init_pin_low_triggers_defaults_write(void) {
    SPI_HandleTypeDef spi = {0};
    GPIO_TypeDef gpio = {0};

    w25q128jv_set_spi_settings_ExpectAnyArgs();
    w25q128jv_init_ExpectAndReturn(1);

    // Pin low => defaults
    HAL_GPIO_ReadPin_ExpectAndReturn(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);

    // Defaults call settings_write_calibration_settings + settings_write_firm_settings,
    // which will: read_sector, erase_sector, write_sector, and read_sector verify.
    // We can satisfy these with broad expectations.
    uint8_t sector[SETTINGS_FLASH_BLOCK_SIZE_BYTES];
    memset(sector, 0, sizeof(sector));

    // A bunch of reads happen; easiest is "ExpectAnyArgs" repeated enough times.
    // If you want stricter, use callbacks/counters.
    w25q128jv_read_sector_ExpectAnyArgs(); w25q128jv_read_sector_ReturnThruPtr_buf(sector);
    w25q128jv_erase_sector_Expect(0);
    w25q128jv_write_sector_ExpectAnyArgs();
    w25q128jv_read_sector_ExpectAnyArgs(); w25q128jv_read_sector_ReturnThruPtr_buf(sector);

    // After defaults, settings_init reads sector again for loading
    w25q128jv_read_sector_ExpectAnyArgs(); w25q128jv_read_sector_ReturnThruPtr_buf(sector);

    // UID should match to pass init
    // defaults sets firmSettings.device_uid from read_UID, so we need to return same UID twice:
    uint64_t uid = 0xABCDEF0123456789ULL;
    w25q128jv_read_UID_ExpectAnyArgs();
    w25q128jv_read_UID_ReturnThruPtr_out((uint8_t*)&uid);
    w25q128jv_read_UID_ExpectAnyArgs();
    w25q128jv_read_UID_ReturnThruPtr_out((uint8_t*)&uid);

    TEST_ASSERT_EQUAL_INT(0, settings_init(&spi, &gpio, 5));
}
